
class Letter(str, Enum):
    A="A"; B="B"; C="C"; D="D"; E="E"; F="F"; G="G"; H="H"; I="I"; J="J"; K="K"; L="L"; M="M"
    N="N"; O="O"; P="P"; Q="Q"; R="R"; S="S"; T="T"; U="U"; V="V"; W="W"; X="X"; Y="Y"; Z="Z"

LETTERS = [l.value for l in Letter]

class LetterReq(BaseModel):
    letter: Letter
    speed: float = 1.0  # 0.2–2.0 works for demo

    @field_validator("speed")
    @classmethod
    def validate_speed(cls, v: float) -> float:
        if v <= 0:
            raise ValueError("speed must be > 0")
        return v

class MotionStatus(BaseModel):
    motion_id: str
    status: str
    progress: int

@app.get("/sign/letters", summary="List supported letters A–Z")
def get_letters():
    return {"supported": LETTERS}

@app.post("/sign/letter", response_model=MotionStatus, summary="Sign one letter A–Z")
async def sign_letter(req: LetterReq):
    mot_id = new_motion_id()
    MOTIONS[mot_id] = Motion(
        motion_id=mot_id,
        kind="LETTER",
        payload={"letter": req.letter, "speed": req.speed, "length": 1},
        created_ms=now_ms(),
        updated_ms=now_ms(),
    )
    asyncio.create_task(simulate_motion(mot_id, units=1, speed=req.speed))
    m = MOTIONS[mot_id]
    return MotionStatus(motion_id=m.motion_id, status=m.status, progress=m.progress)

@app.post("/sign/demo/a_to_z", response_model=MotionStatus, summary="Demo sequence A→Z")
async def demo_a_to_z(speed: float = 1.0):
    mot_id = new_motion_id()
    MOTIONS[mot_id] = Motion(
        motion_id=mot_id,
        kind="DEMO_A_TO_Z",
        payload={"letters": LETTERS, "speed": speed, "length": len(LETTERS)},
        created_ms=now_ms(),
        updated_ms=now_ms(),
    )
    asyncio.create_task(simulate_motion(mot_id, units=len(LETTERS), speed=speed))
    m = MOTIONS[mot_id]
    return MotionStatus(motion_id=m.motion_id, status=m.status, progress=m.progress)
